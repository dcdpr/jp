//! Globally unique workspace ID.
//!
//! This module provides functionality for generating and managing a globally
//! unique workspace ID.
//!
//! The ID is stored in [`crate::Workspace::id`], but can also be stored and
//! accessed globally using [`jp_id::global::set`] and [`jp_id::global::get`].

use std::{
    fs, io,
    path::Path,
    time::{SystemTime, UNIX_EPOCH},
};

static ID_CHARS: &[u8] = b"0123456789abcdefghijklmnopqrstuvwxyz";
static ID_LEN: usize = 5;
static ID_FILE: &str = ".id";
static ID_PREAMBLE: &str = "DO NOT EDIT THIS FILE! IT IS AUTO-GENERATED BY JP.";

/// Generate a globally unique workspace ID.
///
/// Generating a new ID **DOES NOT**:
///
/// - persist it to disk. Use [`store`].
/// - set it as the global ID. Use [`jp_id::global::set`].
#[expect(clippy::missing_panics_doc)]
#[must_use]
pub fn new() -> String {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("valid timestamp")
        .as_millis();

    generate_id_from_timestamp(timestamp)
}

/// Load the globally unique workspace ID from the given root path.
pub fn load(root: impl AsRef<Path>) -> Option<String> {
    fs::read_to_string(root.as_ref().join(ID_FILE))
        .ok()?
        .lines()
        .last()
        .map(ToOwned::to_owned)
}

/// Store the globally unique workspace ID to the given root path.
pub fn store(id: &str, storage: &Path) -> io::Result<()> {
    fs::write(storage.join(ID_FILE), format!("{ID_PREAMBLE}\n{id}"))
}

/// Generates a fixed-length ID from a timestamp using Base63 encoding.
///
/// Takes the least significant digits of the Base63 representation of the
/// timestamp. Pads with '0' if the representation is too short.
fn generate_id_from_timestamp(ts: u128) -> String {
    if ts == 0 {
        return "0".repeat(ID_LEN);
    }

    let base = ID_CHARS.len() as u128;
    let mut num = ts;
    let mut result = vec![b'0'; ID_LEN]; // Pre-fill with '0's

    // Start filling from the rightmost position
    let mut pos = ID_LEN;

    // Generate base36 digits and place from right to left
    while num > 0 && pos > 0 {
        pos -= 1;
        let remainder = (num % base) as usize;
        result[pos] = ID_CHARS[remainder];
        num /= base;
    }

    String::from_utf8(result).expect("valid UTF-8")
}
