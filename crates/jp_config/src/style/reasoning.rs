//! Reasoning content styling configuration.

use std::{fmt, num::ParseIntError};

use schematic::{Config, ConfigEnum};
use serde::{Deserialize, Serialize};

use crate::{
    assignment::{AssignKeyValue, AssignResult, KvAssignment, missing_key},
    delta::{PartialConfigDelta, delta_opt, delta_opt_partial},
    model::{ModelConfig, PartialModelConfig},
    partial::{ToPartial, partial_opt, partial_opt_config},
};

/// Reasoning content style configuration.
#[derive(Debug, Config)]
#[config(rename_all = "snake_case")]
pub struct ReasoningConfig {
    /// Whether to show reasoning blocks.
    #[setting(default)]
    pub display: ReasoningDisplayConfig,

    /// The model to use for summarizing reasoning blocks.
    ///
    /// Defaults to the assistant's default model, but with reasoning disabled.
    #[setting(nested)]
    pub summary_model: Option<ModelConfig>,
}

impl AssignKeyValue for PartialReasoningConfig {
    fn assign(&mut self, mut kv: KvAssignment) -> AssignResult {
        match kv.key_string().as_str() {
            "" => *self = kv.try_object()?,
            "display" => self.display = kv.try_some_from_str()?,
            _ if kv.p("summary_model") => self.summary_model.assign(kv)?,
            _ => return missing_key(&kv),
        }

        Ok(())
    }
}

impl PartialConfigDelta for PartialReasoningConfig {
    fn delta(&self, next: Self) -> Self {
        Self {
            display: delta_opt(self.display.as_ref(), next.display),
            summary_model: delta_opt_partial(self.summary_model.as_ref(), next.summary_model),
        }
    }
}

impl ToPartial for ReasoningConfig {
    fn to_partial(&self) -> Self::Partial {
        let defaults = Self::Partial::default();

        Self::Partial {
            display: partial_opt(&self.display, defaults.display),
            summary_model: partial_opt_config(self.summary_model.as_ref(), defaults.summary_model),
        }
    }
}

/// How to display the reasoning content.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, ConfigEnum)]
#[serde(rename_all = "snake_case")]
#[derive(Default)]
pub enum ReasoningDisplayConfig {
    /// Reasoning is hidden, regardless of the model's capabilities.
    Hidden,

    /// A summary of the reasoning is displayed. This summary is generated by a
    /// separate model.
    Summary,

    /// A static "reasoning..." message is displayed while the assistant is
    /// reasoning.
    Static,

    /// Reasoning content is displayed as it is generated.
    #[default]
    Full,

    /// Show the first N characters of the reasoning content.
    #[variant(fallback)]
    Truncate(TruncateChars),
}

/// Truncate the tool call results to the first N lines.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct TruncateChars {
    /// The number of characters to show.
    pub characters: usize,
}

impl Default for TruncateChars {
    fn default() -> Self {
        Self { characters: 100 }
    }
}

impl TryFrom<&str> for TruncateChars {
    type Error = ParseIntError;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        s.parse().map(|characters| Self { characters })
    }
}

impl fmt::Display for TruncateChars {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.characters)
    }
}
